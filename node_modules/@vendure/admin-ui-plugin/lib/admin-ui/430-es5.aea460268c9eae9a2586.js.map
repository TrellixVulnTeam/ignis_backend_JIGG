{"version":3,"mappings":"wIA0DYA,+EAAc,KACtBA,sBACAA,4DACAA,gBAuCJ,SAAYC,GACRA,gBACAA,gBACAA,kBAHJ,CAAYC,YAAS,KA0RrB,SAAYC,GAERA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YAEAA,YA1TJ,CAAYD,YAAY,KAydxB,SAAYE,GAERA,oBAEAA,4BAJJ,CAAYF,YAAc,KAuB1B,SAAYG,GACRA,gCACAA,0DACAA,wDACAA,8DACAA,8DACAA,wCACAA,oDACAA,sDACAA,wDACAA,wDACAA,oDACAA,sDACAA,sEACAA,wDACAA,oEACAA,8CACAA,kDACAA,oDACAA,kDACAA,wDACAA,0DACAA,sEACAA,sEACAA,gFACAA,gFACAA,0EACAA,0EACAA,0CACAA,gDA7BJ,CAAYH,YAAS,KAwKrB,SAAYI,GACRA,cACAA,gBACAA,oBAHJ,CAAYJ,YAAU,KA+CtB,SAAYK,GACRA,4CACAA,wCACAA,oDACAA,oDACAA,4DACAA,sDACAA,sDACAA,sDACAA,wDACAA,wEACAA,sEACAA,oEACAA,kEACAA,gCACAA,kDACAA,sDACAA,wCACAA,0CACAA,oDACAA,8DACAA,0BACAA,8CACAA,8CACAA,kCAxBJ,CAAYL,YAAgB,KAqH5B,SAAYM,GAERA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,oBAEAA,oBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,gBAEAA,gBAEAA,UAEAA,UAEAA,gBAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UAEAA,UA1TJ,CAAYN,YAAY,KAkVxB,SAAYO,GACRA,YACAA,UAFJ,CAAYP,YAAe,KAwrB3B,SAAYQ,GAERA,gCAEAA,0BAEAA,gBAEAA,kBAEAA,8CAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,kCAEAA,8BAEAA,kCAEAA,kCAEAA,4CAEAA,wCAEAA,4CAEAA,4CAEAA,4BAEAA,wBAEAA,4BAEAA,4BAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,sCAEAA,kCAEAA,sCAEAA,sCAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,kCAEAA,8BAEAA,kCAEAA,kCAEAA,4CAEAA,wCAEAA,4CAEAA,4CAEAA,4BAEAA,wBAEAA,4BAEAA,4BAEAA,4BAEAA,wBAEAA,4BAEAA,4BAEAA,4CAEAA,wCAEAA,4CAEAA,4CAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,oCAEAA,gCAEAA,oCAEAA,oCAEAA,8CAEAA,0CAEAA,8CAEAA,8CAEAA,wBAEAA,oBAEAA,wBAEAA,wBAEAA,wCAEAA,oCAEAA,wCAEAA,wCAEAA,gCAEAA,4BAEAA,gCAEAA,gCAEAA,8BAEAA,0BAEAA,8BAEAA,8BAEAA,0BAEAA,sBAEAA,0BAEAA,0BA1KJ,CAAYR,YAAU,KAosBtB,SAAYS,GACRA,YACAA,cAFJ,CAAYT,YAAS","names":["AdjustmentType","AssetType","exports","CurrencyCode","DeletionResult","ErrorCode","GlobalFlag","HistoryEntryType","LanguageCode","LogicalOperator","Permission","SortOrder"],"sources":["webpack:///common/src/generated-shop-types.ts"],"sourcesContent":["// tslint:disable\nexport type Maybe<T> = T;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n    ID: string | number;\n    String: string;\n    Boolean: boolean;\n    Int: number;\n    Float: number;\n    /** A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar. */\n    DateTime: any;\n    /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */\n    JSON: any;\n    /** The `Upload` scalar type represents a file upload. */\n    Upload: any;\n};\n\nexport type ActiveOrderResult = Order | NoActiveOrderError;\n\nexport type AddPaymentToOrderResult =\n    | Order\n    | OrderPaymentStateError\n    | IneligiblePaymentMethodError\n    | PaymentFailedError\n    | PaymentDeclinedError\n    | OrderStateTransitionError\n    | NoActiveOrderError;\n\nexport type Address = Node & {\n    __typename?: 'Address';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    fullName?: Maybe<Scalars['String']>;\n    company?: Maybe<Scalars['String']>;\n    streetLine1: Scalars['String'];\n    streetLine2?: Maybe<Scalars['String']>;\n    city?: Maybe<Scalars['String']>;\n    province?: Maybe<Scalars['String']>;\n    postalCode?: Maybe<Scalars['String']>;\n    country: Country;\n    phoneNumber?: Maybe<Scalars['String']>;\n    defaultShippingAddress?: Maybe<Scalars['Boolean']>;\n    defaultBillingAddress?: Maybe<Scalars['Boolean']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type Adjustment = {\n    __typename?: 'Adjustment';\n    adjustmentSource: Scalars['String'];\n    type: AdjustmentType;\n    description: Scalars['String'];\n    amount: Scalars['Int'];\n};\n\nexport enum AdjustmentType {\n    PROMOTION = 'PROMOTION',\n    DISTRIBUTED_ORDER_PROMOTION = 'DISTRIBUTED_ORDER_PROMOTION',\n    OTHER = 'OTHER',\n}\n\n/** Returned when attempting to set the Customer for an Order when already logged in. */\nexport type AlreadyLoggedInError = ErrorResult & {\n    __typename?: 'AlreadyLoggedInError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type ApplyCouponCodeResult =\n    | Order\n    | CouponCodeExpiredError\n    | CouponCodeInvalidError\n    | CouponCodeLimitError;\n\nexport type Asset = Node & {\n    __typename?: 'Asset';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    name: Scalars['String'];\n    type: AssetType;\n    fileSize: Scalars['Int'];\n    mimeType: Scalars['String'];\n    width: Scalars['Int'];\n    height: Scalars['Int'];\n    source: Scalars['String'];\n    preview: Scalars['String'];\n    focalPoint?: Maybe<Coordinate>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type AssetList = PaginatedList & {\n    __typename?: 'AssetList';\n    items: Array<Asset>;\n    totalItems: Scalars['Int'];\n};\n\nexport enum AssetType {\n    IMAGE = 'IMAGE',\n    VIDEO = 'VIDEO',\n    BINARY = 'BINARY',\n}\n\nexport type AuthenticationInput = {\n    native?: Maybe<NativeAuthInput>;\n};\n\nexport type AuthenticationMethod = Node & {\n    __typename?: 'AuthenticationMethod';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    strategy: Scalars['String'];\n};\n\nexport type AuthenticationResult = CurrentUser | InvalidCredentialsError | NotVerifiedError;\n\nexport type BooleanCustomFieldConfig = CustomField & {\n    __typename?: 'BooleanCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\n/** Operators for filtering on a list of Boolean fields */\nexport type BooleanListOperators = {\n    inList: Scalars['Boolean'];\n};\n\n/** Operators for filtering on a Boolean field */\nexport type BooleanOperators = {\n    eq?: Maybe<Scalars['Boolean']>;\n};\n\nexport type Channel = Node & {\n    __typename?: 'Channel';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    code: Scalars['String'];\n    token: Scalars['String'];\n    defaultTaxZone?: Maybe<Zone>;\n    defaultShippingZone?: Maybe<Zone>;\n    defaultLanguageCode: LanguageCode;\n    currencyCode: CurrencyCode;\n    pricesIncludeTax: Scalars['Boolean'];\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type Collection = Node & {\n    __typename?: 'Collection';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode?: Maybe<LanguageCode>;\n    name: Scalars['String'];\n    slug: Scalars['String'];\n    breadcrumbs: Array<CollectionBreadcrumb>;\n    position: Scalars['Int'];\n    description: Scalars['String'];\n    featuredAsset?: Maybe<Asset>;\n    assets: Array<Asset>;\n    parent?: Maybe<Collection>;\n    children?: Maybe<Array<Collection>>;\n    filters: Array<ConfigurableOperation>;\n    translations: Array<CollectionTranslation>;\n    productVariants: ProductVariantList;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type CollectionProductVariantsArgs = {\n    options?: Maybe<ProductVariantListOptions>;\n};\n\nexport type CollectionBreadcrumb = {\n    __typename?: 'CollectionBreadcrumb';\n    id: Scalars['ID'];\n    name: Scalars['String'];\n    slug: Scalars['String'];\n};\n\nexport type CollectionFilterParameter = {\n    id?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    languageCode?: Maybe<StringOperators>;\n    name?: Maybe<StringOperators>;\n    slug?: Maybe<StringOperators>;\n    position?: Maybe<NumberOperators>;\n    description?: Maybe<StringOperators>;\n};\n\nexport type CollectionList = PaginatedList & {\n    __typename?: 'CollectionList';\n    items: Array<Collection>;\n    totalItems: Scalars['Int'];\n};\n\nexport type CollectionListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<CollectionSortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<CollectionFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\n/**\n * Which Collections are present in the products returned\n * by the search, and in what quantity.\n */\nexport type CollectionResult = {\n    __typename?: 'CollectionResult';\n    collection: Collection;\n    count: Scalars['Int'];\n};\n\nexport type CollectionSortParameter = {\n    id?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n    name?: Maybe<SortOrder>;\n    slug?: Maybe<SortOrder>;\n    position?: Maybe<SortOrder>;\n    description?: Maybe<SortOrder>;\n};\n\nexport type CollectionTranslation = {\n    __typename?: 'CollectionTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n    slug: Scalars['String'];\n    description: Scalars['String'];\n};\n\nexport type ConfigArg = {\n    __typename?: 'ConfigArg';\n    name: Scalars['String'];\n    value: Scalars['String'];\n};\n\nexport type ConfigArgDefinition = {\n    __typename?: 'ConfigArgDefinition';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    required: Scalars['Boolean'];\n    defaultValue?: Maybe<Scalars['JSON']>;\n    label?: Maybe<Scalars['String']>;\n    description?: Maybe<Scalars['String']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type ConfigArgInput = {\n    name: Scalars['String'];\n    /** A JSON stringified representation of the actual value */\n    value: Scalars['String'];\n};\n\nexport type ConfigurableOperation = {\n    __typename?: 'ConfigurableOperation';\n    code: Scalars['String'];\n    args: Array<ConfigArg>;\n};\n\nexport type ConfigurableOperationDefinition = {\n    __typename?: 'ConfigurableOperationDefinition';\n    code: Scalars['String'];\n    args: Array<ConfigArgDefinition>;\n    description: Scalars['String'];\n};\n\nexport type ConfigurableOperationInput = {\n    code: Scalars['String'];\n    arguments: Array<ConfigArgInput>;\n};\n\nexport type Coordinate = {\n    __typename?: 'Coordinate';\n    x: Scalars['Float'];\n    y: Scalars['Float'];\n};\n\nexport type Country = Node & {\n    __typename?: 'Country';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    code: Scalars['String'];\n    name: Scalars['String'];\n    enabled: Scalars['Boolean'];\n    translations: Array<CountryTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type CountryList = PaginatedList & {\n    __typename?: 'CountryList';\n    items: Array<Country>;\n    totalItems: Scalars['Int'];\n};\n\nexport type CountryTranslation = {\n    __typename?: 'CountryTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n};\n\n/** Returned if the provided coupon code is invalid */\nexport type CouponCodeExpiredError = ErrorResult & {\n    __typename?: 'CouponCodeExpiredError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    couponCode: Scalars['String'];\n};\n\n/** Returned if the provided coupon code is invalid */\nexport type CouponCodeInvalidError = ErrorResult & {\n    __typename?: 'CouponCodeInvalidError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    couponCode: Scalars['String'];\n};\n\n/** Returned if the provided coupon code is invalid */\nexport type CouponCodeLimitError = ErrorResult & {\n    __typename?: 'CouponCodeLimitError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    couponCode: Scalars['String'];\n    limit: Scalars['Int'];\n};\n\nexport type CreateAddressInput = {\n    fullName?: Maybe<Scalars['String']>;\n    company?: Maybe<Scalars['String']>;\n    streetLine1: Scalars['String'];\n    streetLine2?: Maybe<Scalars['String']>;\n    city?: Maybe<Scalars['String']>;\n    province?: Maybe<Scalars['String']>;\n    postalCode?: Maybe<Scalars['String']>;\n    countryCode: Scalars['String'];\n    phoneNumber?: Maybe<Scalars['String']>;\n    defaultShippingAddress?: Maybe<Scalars['Boolean']>;\n    defaultBillingAddress?: Maybe<Scalars['Boolean']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type CreateCustomerInput = {\n    title?: Maybe<Scalars['String']>;\n    firstName: Scalars['String'];\n    lastName: Scalars['String'];\n    phoneNumber?: Maybe<Scalars['String']>;\n    emailAddress: Scalars['String'];\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\n/**\n * @description\n * ISO 4217 currency code\n *\n * @docsCategory common\n */\nexport enum CurrencyCode {\n    /** United Arab Emirates dirham */\n    AED = 'AED',\n    /** Afghan afghani */\n    AFN = 'AFN',\n    /** Albanian lek */\n    ALL = 'ALL',\n    /** Armenian dram */\n    AMD = 'AMD',\n    /** Netherlands Antillean guilder */\n    ANG = 'ANG',\n    /** Angolan kwanza */\n    AOA = 'AOA',\n    /** Argentine peso */\n    ARS = 'ARS',\n    /** Australian dollar */\n    AUD = 'AUD',\n    /** Aruban florin */\n    AWG = 'AWG',\n    /** Azerbaijani manat */\n    AZN = 'AZN',\n    /** Bosnia and Herzegovina convertible mark */\n    BAM = 'BAM',\n    /** Barbados dollar */\n    BBD = 'BBD',\n    /** Bangladeshi taka */\n    BDT = 'BDT',\n    /** Bulgarian lev */\n    BGN = 'BGN',\n    /** Bahraini dinar */\n    BHD = 'BHD',\n    /** Burundian franc */\n    BIF = 'BIF',\n    /** Bermudian dollar */\n    BMD = 'BMD',\n    /** Brunei dollar */\n    BND = 'BND',\n    /** Boliviano */\n    BOB = 'BOB',\n    /** Brazilian real */\n    BRL = 'BRL',\n    /** Bahamian dollar */\n    BSD = 'BSD',\n    /** Bhutanese ngultrum */\n    BTN = 'BTN',\n    /** Botswana pula */\n    BWP = 'BWP',\n    /** Belarusian ruble */\n    BYN = 'BYN',\n    /** Belize dollar */\n    BZD = 'BZD',\n    /** Canadian dollar */\n    CAD = 'CAD',\n    /** Congolese franc */\n    CDF = 'CDF',\n    /** Swiss franc */\n    CHF = 'CHF',\n    /** Chilean peso */\n    CLP = 'CLP',\n    /** Renminbi (Chinese) yuan */\n    CNY = 'CNY',\n    /** Colombian peso */\n    COP = 'COP',\n    /** Costa Rican colon */\n    CRC = 'CRC',\n    /** Cuban convertible peso */\n    CUC = 'CUC',\n    /** Cuban peso */\n    CUP = 'CUP',\n    /** Cape Verde escudo */\n    CVE = 'CVE',\n    /** Czech koruna */\n    CZK = 'CZK',\n    /** Djiboutian franc */\n    DJF = 'DJF',\n    /** Danish krone */\n    DKK = 'DKK',\n    /** Dominican peso */\n    DOP = 'DOP',\n    /** Algerian dinar */\n    DZD = 'DZD',\n    /** Egyptian pound */\n    EGP = 'EGP',\n    /** Eritrean nakfa */\n    ERN = 'ERN',\n    /** Ethiopian birr */\n    ETB = 'ETB',\n    /** Euro */\n    EUR = 'EUR',\n    /** Fiji dollar */\n    FJD = 'FJD',\n    /** Falkland Islands pound */\n    FKP = 'FKP',\n    /** Pound sterling */\n    GBP = 'GBP',\n    /** Georgian lari */\n    GEL = 'GEL',\n    /** Ghanaian cedi */\n    GHS = 'GHS',\n    /** Gibraltar pound */\n    GIP = 'GIP',\n    /** Gambian dalasi */\n    GMD = 'GMD',\n    /** Guinean franc */\n    GNF = 'GNF',\n    /** Guatemalan quetzal */\n    GTQ = 'GTQ',\n    /** Guyanese dollar */\n    GYD = 'GYD',\n    /** Hong Kong dollar */\n    HKD = 'HKD',\n    /** Honduran lempira */\n    HNL = 'HNL',\n    /** Croatian kuna */\n    HRK = 'HRK',\n    /** Haitian gourde */\n    HTG = 'HTG',\n    /** Hungarian forint */\n    HUF = 'HUF',\n    /** Indonesian rupiah */\n    IDR = 'IDR',\n    /** Israeli new shekel */\n    ILS = 'ILS',\n    /** Indian rupee */\n    INR = 'INR',\n    /** Iraqi dinar */\n    IQD = 'IQD',\n    /** Iranian rial */\n    IRR = 'IRR',\n    /** Icelandic króna */\n    ISK = 'ISK',\n    /** Jamaican dollar */\n    JMD = 'JMD',\n    /** Jordanian dinar */\n    JOD = 'JOD',\n    /** Japanese yen */\n    JPY = 'JPY',\n    /** Kenyan shilling */\n    KES = 'KES',\n    /** Kyrgyzstani som */\n    KGS = 'KGS',\n    /** Cambodian riel */\n    KHR = 'KHR',\n    /** Comoro franc */\n    KMF = 'KMF',\n    /** North Korean won */\n    KPW = 'KPW',\n    /** South Korean won */\n    KRW = 'KRW',\n    /** Kuwaiti dinar */\n    KWD = 'KWD',\n    /** Cayman Islands dollar */\n    KYD = 'KYD',\n    /** Kazakhstani tenge */\n    KZT = 'KZT',\n    /** Lao kip */\n    LAK = 'LAK',\n    /** Lebanese pound */\n    LBP = 'LBP',\n    /** Sri Lankan rupee */\n    LKR = 'LKR',\n    /** Liberian dollar */\n    LRD = 'LRD',\n    /** Lesotho loti */\n    LSL = 'LSL',\n    /** Libyan dinar */\n    LYD = 'LYD',\n    /** Moroccan dirham */\n    MAD = 'MAD',\n    /** Moldovan leu */\n    MDL = 'MDL',\n    /** Malagasy ariary */\n    MGA = 'MGA',\n    /** Macedonian denar */\n    MKD = 'MKD',\n    /** Myanmar kyat */\n    MMK = 'MMK',\n    /** Mongolian tögrög */\n    MNT = 'MNT',\n    /** Macanese pataca */\n    MOP = 'MOP',\n    /** Mauritanian ouguiya */\n    MRU = 'MRU',\n    /** Mauritian rupee */\n    MUR = 'MUR',\n    /** Maldivian rufiyaa */\n    MVR = 'MVR',\n    /** Malawian kwacha */\n    MWK = 'MWK',\n    /** Mexican peso */\n    MXN = 'MXN',\n    /** Malaysian ringgit */\n    MYR = 'MYR',\n    /** Mozambican metical */\n    MZN = 'MZN',\n    /** Namibian dollar */\n    NAD = 'NAD',\n    /** Nigerian naira */\n    NGN = 'NGN',\n    /** Nicaraguan córdoba */\n    NIO = 'NIO',\n    /** Norwegian krone */\n    NOK = 'NOK',\n    /** Nepalese rupee */\n    NPR = 'NPR',\n    /** New Zealand dollar */\n    NZD = 'NZD',\n    /** Omani rial */\n    OMR = 'OMR',\n    /** Panamanian balboa */\n    PAB = 'PAB',\n    /** Peruvian sol */\n    PEN = 'PEN',\n    /** Papua New Guinean kina */\n    PGK = 'PGK',\n    /** Philippine peso */\n    PHP = 'PHP',\n    /** Pakistani rupee */\n    PKR = 'PKR',\n    /** Polish złoty */\n    PLN = 'PLN',\n    /** Paraguayan guaraní */\n    PYG = 'PYG',\n    /** Qatari riyal */\n    QAR = 'QAR',\n    /** Romanian leu */\n    RON = 'RON',\n    /** Serbian dinar */\n    RSD = 'RSD',\n    /** Russian ruble */\n    RUB = 'RUB',\n    /** Rwandan franc */\n    RWF = 'RWF',\n    /** Saudi riyal */\n    SAR = 'SAR',\n    /** Solomon Islands dollar */\n    SBD = 'SBD',\n    /** Seychelles rupee */\n    SCR = 'SCR',\n    /** Sudanese pound */\n    SDG = 'SDG',\n    /** Swedish krona/kronor */\n    SEK = 'SEK',\n    /** Singapore dollar */\n    SGD = 'SGD',\n    /** Saint Helena pound */\n    SHP = 'SHP',\n    /** Sierra Leonean leone */\n    SLL = 'SLL',\n    /** Somali shilling */\n    SOS = 'SOS',\n    /** Surinamese dollar */\n    SRD = 'SRD',\n    /** South Sudanese pound */\n    SSP = 'SSP',\n    /** São Tomé and Príncipe dobra */\n    STN = 'STN',\n    /** Salvadoran colón */\n    SVC = 'SVC',\n    /** Syrian pound */\n    SYP = 'SYP',\n    /** Swazi lilangeni */\n    SZL = 'SZL',\n    /** Thai baht */\n    THB = 'THB',\n    /** Tajikistani somoni */\n    TJS = 'TJS',\n    /** Turkmenistan manat */\n    TMT = 'TMT',\n    /** Tunisian dinar */\n    TND = 'TND',\n    /** Tongan paʻanga */\n    TOP = 'TOP',\n    /** Turkish lira */\n    TRY = 'TRY',\n    /** Trinidad and Tobago dollar */\n    TTD = 'TTD',\n    /** New Taiwan dollar */\n    TWD = 'TWD',\n    /** Tanzanian shilling */\n    TZS = 'TZS',\n    /** Ukrainian hryvnia */\n    UAH = 'UAH',\n    /** Ugandan shilling */\n    UGX = 'UGX',\n    /** United States dollar */\n    USD = 'USD',\n    /** Uruguayan peso */\n    UYU = 'UYU',\n    /** Uzbekistan som */\n    UZS = 'UZS',\n    /** Venezuelan bolívar soberano */\n    VES = 'VES',\n    /** Vietnamese đồng */\n    VND = 'VND',\n    /** Vanuatu vatu */\n    VUV = 'VUV',\n    /** Samoan tala */\n    WST = 'WST',\n    /** CFA franc BEAC */\n    XAF = 'XAF',\n    /** East Caribbean dollar */\n    XCD = 'XCD',\n    /** CFA franc BCEAO */\n    XOF = 'XOF',\n    /** CFP franc (franc Pacifique) */\n    XPF = 'XPF',\n    /** Yemeni rial */\n    YER = 'YER',\n    /** South African rand */\n    ZAR = 'ZAR',\n    /** Zambian kwacha */\n    ZMW = 'ZMW',\n    /** Zimbabwean dollar */\n    ZWL = 'ZWL',\n}\n\nexport type CurrentUser = {\n    __typename?: 'CurrentUser';\n    id: Scalars['ID'];\n    identifier: Scalars['String'];\n    channels: Array<CurrentUserChannel>;\n};\n\nexport type CurrentUserChannel = {\n    __typename?: 'CurrentUserChannel';\n    id: Scalars['ID'];\n    token: Scalars['String'];\n    code: Scalars['String'];\n    permissions: Array<Permission>;\n};\n\nexport type CustomField = {\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type CustomFieldConfig =\n    | StringCustomFieldConfig\n    | LocaleStringCustomFieldConfig\n    | IntCustomFieldConfig\n    | FloatCustomFieldConfig\n    | BooleanCustomFieldConfig\n    | DateTimeCustomFieldConfig\n    | RelationCustomFieldConfig\n    | TextCustomFieldConfig;\n\nexport type Customer = Node & {\n    __typename?: 'Customer';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    title?: Maybe<Scalars['String']>;\n    firstName: Scalars['String'];\n    lastName: Scalars['String'];\n    phoneNumber?: Maybe<Scalars['String']>;\n    emailAddress: Scalars['String'];\n    addresses?: Maybe<Array<Address>>;\n    orders: OrderList;\n    user?: Maybe<User>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type CustomerOrdersArgs = {\n    options?: Maybe<OrderListOptions>;\n};\n\nexport type CustomerFilterParameter = {\n    id?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    title?: Maybe<StringOperators>;\n    firstName?: Maybe<StringOperators>;\n    lastName?: Maybe<StringOperators>;\n    phoneNumber?: Maybe<StringOperators>;\n    emailAddress?: Maybe<StringOperators>;\n};\n\nexport type CustomerGroup = Node & {\n    __typename?: 'CustomerGroup';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    name: Scalars['String'];\n    customers: CustomerList;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type CustomerGroupCustomersArgs = {\n    options?: Maybe<CustomerListOptions>;\n};\n\nexport type CustomerList = PaginatedList & {\n    __typename?: 'CustomerList';\n    items: Array<Customer>;\n    totalItems: Scalars['Int'];\n};\n\nexport type CustomerListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<CustomerSortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<CustomerFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\nexport type CustomerSortParameter = {\n    id?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n    title?: Maybe<SortOrder>;\n    firstName?: Maybe<SortOrder>;\n    lastName?: Maybe<SortOrder>;\n    phoneNumber?: Maybe<SortOrder>;\n    emailAddress?: Maybe<SortOrder>;\n};\n\n/** Operators for filtering on a list of Date fields */\nexport type DateListOperators = {\n    inList: Scalars['DateTime'];\n};\n\n/** Operators for filtering on a DateTime field */\nexport type DateOperators = {\n    eq?: Maybe<Scalars['DateTime']>;\n    before?: Maybe<Scalars['DateTime']>;\n    after?: Maybe<Scalars['DateTime']>;\n    between?: Maybe<DateRange>;\n};\n\nexport type DateRange = {\n    start: Scalars['DateTime'];\n    end: Scalars['DateTime'];\n};\n\n/**\n * Expects the same validation formats as the `<input type=\"datetime-local\">` HTML element.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime-local#Additional_attributes\n */\nexport type DateTimeCustomFieldConfig = CustomField & {\n    __typename?: 'DateTimeCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    min?: Maybe<Scalars['String']>;\n    max?: Maybe<Scalars['String']>;\n    step?: Maybe<Scalars['Int']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type DeletionResponse = {\n    __typename?: 'DeletionResponse';\n    result: DeletionResult;\n    message?: Maybe<Scalars['String']>;\n};\n\nexport enum DeletionResult {\n    /** The entity was successfully deleted */\n    DELETED = 'DELETED',\n    /** Deletion did not take place, reason given in message */\n    NOT_DELETED = 'NOT_DELETED',\n}\n\nexport type Discount = {\n    __typename?: 'Discount';\n    adjustmentSource: Scalars['String'];\n    type: AdjustmentType;\n    description: Scalars['String'];\n    amount: Scalars['Int'];\n    amountWithTax: Scalars['Int'];\n};\n\n/** Returned when attempting to create a Customer with an email address already registered to an existing User. */\nexport type EmailAddressConflictError = ErrorResult & {\n    __typename?: 'EmailAddressConflictError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport enum ErrorCode {\n    UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n    NATIVE_AUTH_STRATEGY_ERROR = 'NATIVE_AUTH_STRATEGY_ERROR',\n    INVALID_CREDENTIALS_ERROR = 'INVALID_CREDENTIALS_ERROR',\n    ORDER_STATE_TRANSITION_ERROR = 'ORDER_STATE_TRANSITION_ERROR',\n    EMAIL_ADDRESS_CONFLICT_ERROR = 'EMAIL_ADDRESS_CONFLICT_ERROR',\n    ORDER_LIMIT_ERROR = 'ORDER_LIMIT_ERROR',\n    NEGATIVE_QUANTITY_ERROR = 'NEGATIVE_QUANTITY_ERROR',\n    INSUFFICIENT_STOCK_ERROR = 'INSUFFICIENT_STOCK_ERROR',\n    COUPON_CODE_INVALID_ERROR = 'COUPON_CODE_INVALID_ERROR',\n    COUPON_CODE_EXPIRED_ERROR = 'COUPON_CODE_EXPIRED_ERROR',\n    COUPON_CODE_LIMIT_ERROR = 'COUPON_CODE_LIMIT_ERROR',\n    ORDER_MODIFICATION_ERROR = 'ORDER_MODIFICATION_ERROR',\n    INELIGIBLE_SHIPPING_METHOD_ERROR = 'INELIGIBLE_SHIPPING_METHOD_ERROR',\n    ORDER_PAYMENT_STATE_ERROR = 'ORDER_PAYMENT_STATE_ERROR',\n    INELIGIBLE_PAYMENT_METHOD_ERROR = 'INELIGIBLE_PAYMENT_METHOD_ERROR',\n    PAYMENT_FAILED_ERROR = 'PAYMENT_FAILED_ERROR',\n    PAYMENT_DECLINED_ERROR = 'PAYMENT_DECLINED_ERROR',\n    ALREADY_LOGGED_IN_ERROR = 'ALREADY_LOGGED_IN_ERROR',\n    MISSING_PASSWORD_ERROR = 'MISSING_PASSWORD_ERROR',\n    PASSWORD_VALIDATION_ERROR = 'PASSWORD_VALIDATION_ERROR',\n    PASSWORD_ALREADY_SET_ERROR = 'PASSWORD_ALREADY_SET_ERROR',\n    VERIFICATION_TOKEN_INVALID_ERROR = 'VERIFICATION_TOKEN_INVALID_ERROR',\n    VERIFICATION_TOKEN_EXPIRED_ERROR = 'VERIFICATION_TOKEN_EXPIRED_ERROR',\n    IDENTIFIER_CHANGE_TOKEN_INVALID_ERROR = 'IDENTIFIER_CHANGE_TOKEN_INVALID_ERROR',\n    IDENTIFIER_CHANGE_TOKEN_EXPIRED_ERROR = 'IDENTIFIER_CHANGE_TOKEN_EXPIRED_ERROR',\n    PASSWORD_RESET_TOKEN_INVALID_ERROR = 'PASSWORD_RESET_TOKEN_INVALID_ERROR',\n    PASSWORD_RESET_TOKEN_EXPIRED_ERROR = 'PASSWORD_RESET_TOKEN_EXPIRED_ERROR',\n    NOT_VERIFIED_ERROR = 'NOT_VERIFIED_ERROR',\n    NO_ACTIVE_ORDER_ERROR = 'NO_ACTIVE_ORDER_ERROR',\n}\n\nexport type ErrorResult = {\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type Facet = Node & {\n    __typename?: 'Facet';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n    code: Scalars['String'];\n    values: Array<FacetValue>;\n    translations: Array<FacetTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type FacetFilterParameter = {\n    id?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    languageCode?: Maybe<StringOperators>;\n    name?: Maybe<StringOperators>;\n    code?: Maybe<StringOperators>;\n};\n\nexport type FacetList = PaginatedList & {\n    __typename?: 'FacetList';\n    items: Array<Facet>;\n    totalItems: Scalars['Int'];\n};\n\nexport type FacetListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<FacetSortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<FacetFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\nexport type FacetSortParameter = {\n    id?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n    name?: Maybe<SortOrder>;\n    code?: Maybe<SortOrder>;\n};\n\nexport type FacetTranslation = {\n    __typename?: 'FacetTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n};\n\nexport type FacetValue = Node & {\n    __typename?: 'FacetValue';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    facet: Facet;\n    name: Scalars['String'];\n    code: Scalars['String'];\n    translations: Array<FacetValueTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\n/**\n * Used to construct boolean expressions for filtering search results\n * by FacetValue ID. Examples:\n *\n * * ID=1 OR ID=2: `{ facetValueFilters: [{ or: [1,2] }] }`\n * * ID=1 AND ID=2: `{ facetValueFilters: [{ and: 1 }, { and: 2 }] }`\n * * ID=1 AND (ID=2 OR ID=3): `{ facetValueFilters: [{ and: 1 }, { or: [2,3] }] }`\n */\nexport type FacetValueFilterInput = {\n    and?: Maybe<Scalars['ID']>;\n    or?: Maybe<Array<Scalars['ID']>>;\n};\n\n/**\n * Which FacetValues are present in the products returned\n * by the search, and in what quantity.\n */\nexport type FacetValueResult = {\n    __typename?: 'FacetValueResult';\n    facetValue: FacetValue;\n    count: Scalars['Int'];\n};\n\nexport type FacetValueTranslation = {\n    __typename?: 'FacetValueTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n};\n\nexport type FloatCustomFieldConfig = CustomField & {\n    __typename?: 'FloatCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    min?: Maybe<Scalars['Float']>;\n    max?: Maybe<Scalars['Float']>;\n    step?: Maybe<Scalars['Float']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type Fulfillment = Node & {\n    __typename?: 'Fulfillment';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    orderItems: Array<OrderItem>;\n    state: Scalars['String'];\n    method: Scalars['String'];\n    trackingCode?: Maybe<Scalars['String']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport enum GlobalFlag {\n    TRUE = 'TRUE',\n    FALSE = 'FALSE',\n    INHERIT = 'INHERIT',\n}\n\nexport type HistoryEntry = Node & {\n    __typename?: 'HistoryEntry';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    type: HistoryEntryType;\n    data: Scalars['JSON'];\n};\n\nexport type HistoryEntryFilterParameter = {\n    id?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    type?: Maybe<StringOperators>;\n};\n\nexport type HistoryEntryList = PaginatedList & {\n    __typename?: 'HistoryEntryList';\n    items: Array<HistoryEntry>;\n    totalItems: Scalars['Int'];\n};\n\nexport type HistoryEntryListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<HistoryEntrySortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<HistoryEntryFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\nexport type HistoryEntrySortParameter = {\n    id?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n};\n\nexport enum HistoryEntryType {\n    CUSTOMER_REGISTERED = 'CUSTOMER_REGISTERED',\n    CUSTOMER_VERIFIED = 'CUSTOMER_VERIFIED',\n    CUSTOMER_DETAIL_UPDATED = 'CUSTOMER_DETAIL_UPDATED',\n    CUSTOMER_ADDED_TO_GROUP = 'CUSTOMER_ADDED_TO_GROUP',\n    CUSTOMER_REMOVED_FROM_GROUP = 'CUSTOMER_REMOVED_FROM_GROUP',\n    CUSTOMER_ADDRESS_CREATED = 'CUSTOMER_ADDRESS_CREATED',\n    CUSTOMER_ADDRESS_UPDATED = 'CUSTOMER_ADDRESS_UPDATED',\n    CUSTOMER_ADDRESS_DELETED = 'CUSTOMER_ADDRESS_DELETED',\n    CUSTOMER_PASSWORD_UPDATED = 'CUSTOMER_PASSWORD_UPDATED',\n    CUSTOMER_PASSWORD_RESET_REQUESTED = 'CUSTOMER_PASSWORD_RESET_REQUESTED',\n    CUSTOMER_PASSWORD_RESET_VERIFIED = 'CUSTOMER_PASSWORD_RESET_VERIFIED',\n    CUSTOMER_EMAIL_UPDATE_REQUESTED = 'CUSTOMER_EMAIL_UPDATE_REQUESTED',\n    CUSTOMER_EMAIL_UPDATE_VERIFIED = 'CUSTOMER_EMAIL_UPDATE_VERIFIED',\n    CUSTOMER_NOTE = 'CUSTOMER_NOTE',\n    ORDER_STATE_TRANSITION = 'ORDER_STATE_TRANSITION',\n    ORDER_PAYMENT_TRANSITION = 'ORDER_PAYMENT_TRANSITION',\n    ORDER_FULFILLMENT = 'ORDER_FULFILLMENT',\n    ORDER_CANCELLATION = 'ORDER_CANCELLATION',\n    ORDER_REFUND_TRANSITION = 'ORDER_REFUND_TRANSITION',\n    ORDER_FULFILLMENT_TRANSITION = 'ORDER_FULFILLMENT_TRANSITION',\n    ORDER_NOTE = 'ORDER_NOTE',\n    ORDER_COUPON_APPLIED = 'ORDER_COUPON_APPLIED',\n    ORDER_COUPON_REMOVED = 'ORDER_COUPON_REMOVED',\n    ORDER_MODIFIED = 'ORDER_MODIFIED',\n}\n\n/** Operators for filtering on a list of ID fields */\nexport type IdListOperators = {\n    inList: Scalars['ID'];\n};\n\n/** Operators for filtering on an ID field */\nexport type IdOperators = {\n    eq?: Maybe<Scalars['String']>;\n    notEq?: Maybe<Scalars['String']>;\n    in?: Maybe<Array<Scalars['String']>>;\n    notIn?: Maybe<Array<Scalars['String']>>;\n};\n\n/**\n * Returned if the token used to change a Customer's email address is valid, but has\n * expired according to the `verificationTokenDuration` setting in the AuthOptions.\n */\nexport type IdentifierChangeTokenExpiredError = ErrorResult & {\n    __typename?: 'IdentifierChangeTokenExpiredError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/**\n * Returned if the token used to change a Customer's email address is either\n * invalid or does not match any expected tokens.\n */\nexport type IdentifierChangeTokenInvalidError = ErrorResult & {\n    __typename?: 'IdentifierChangeTokenInvalidError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/** Returned when attempting to add a Payment using a PaymentMethod for which the Order is not eligible. */\nexport type IneligiblePaymentMethodError = ErrorResult & {\n    __typename?: 'IneligiblePaymentMethodError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    eligibilityCheckerMessage?: Maybe<Scalars['String']>;\n};\n\n/** Returned when attempting to set a ShippingMethod for which the Order is not eligible */\nexport type IneligibleShippingMethodError = ErrorResult & {\n    __typename?: 'IneligibleShippingMethodError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/** Returned when attempting to add more items to the Order than are available */\nexport type InsufficientStockError = ErrorResult & {\n    __typename?: 'InsufficientStockError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    quantityAvailable: Scalars['Int'];\n    order: Order;\n};\n\nexport type IntCustomFieldConfig = CustomField & {\n    __typename?: 'IntCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    min?: Maybe<Scalars['Int']>;\n    max?: Maybe<Scalars['Int']>;\n    step?: Maybe<Scalars['Int']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\n/** Returned if the user authentication credentials are not valid */\nexport type InvalidCredentialsError = ErrorResult & {\n    __typename?: 'InvalidCredentialsError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    authenticationError: Scalars['String'];\n};\n\n/**\n * @description\n * Languages in the form of a ISO 639-1 language code with optional\n * region or script modifier (e.g. de_AT). The selection available is based\n * on the [Unicode CLDR summary list](https://unicode-org.github.io/cldr-staging/charts/37/summary/root.html)\n * and includes the major spoken languages of the world and any widely-used variants.\n *\n * @docsCategory common\n */\nexport enum LanguageCode {\n    /** Afrikaans */\n    af = 'af',\n    /** Akan */\n    ak = 'ak',\n    /** Albanian */\n    sq = 'sq',\n    /** Amharic */\n    am = 'am',\n    /** Arabic */\n    ar = 'ar',\n    /** Armenian */\n    hy = 'hy',\n    /** Assamese */\n    as = 'as',\n    /** Azerbaijani */\n    az = 'az',\n    /** Bambara */\n    bm = 'bm',\n    /** Bangla */\n    bn = 'bn',\n    /** Basque */\n    eu = 'eu',\n    /** Belarusian */\n    be = 'be',\n    /** Bosnian */\n    bs = 'bs',\n    /** Breton */\n    br = 'br',\n    /** Bulgarian */\n    bg = 'bg',\n    /** Burmese */\n    my = 'my',\n    /** Catalan */\n    ca = 'ca',\n    /** Chechen */\n    ce = 'ce',\n    /** Chinese */\n    zh = 'zh',\n    /** Simplified Chinese */\n    zh_Hans = 'zh_Hans',\n    /** Traditional Chinese */\n    zh_Hant = 'zh_Hant',\n    /** Church Slavic */\n    cu = 'cu',\n    /** Cornish */\n    kw = 'kw',\n    /** Corsican */\n    co = 'co',\n    /** Croatian */\n    hr = 'hr',\n    /** Czech */\n    cs = 'cs',\n    /** Danish */\n    da = 'da',\n    /** Dutch */\n    nl = 'nl',\n    /** Flemish */\n    nl_BE = 'nl_BE',\n    /** Dzongkha */\n    dz = 'dz',\n    /** English */\n    en = 'en',\n    /** Australian English */\n    en_AU = 'en_AU',\n    /** Canadian English */\n    en_CA = 'en_CA',\n    /** British English */\n    en_GB = 'en_GB',\n    /** American English */\n    en_US = 'en_US',\n    /** Esperanto */\n    eo = 'eo',\n    /** Estonian */\n    et = 'et',\n    /** Ewe */\n    ee = 'ee',\n    /** Faroese */\n    fo = 'fo',\n    /** Finnish */\n    fi = 'fi',\n    /** French */\n    fr = 'fr',\n    /** Canadian French */\n    fr_CA = 'fr_CA',\n    /** Swiss French */\n    fr_CH = 'fr_CH',\n    /** Fulah */\n    ff = 'ff',\n    /** Galician */\n    gl = 'gl',\n    /** Ganda */\n    lg = 'lg',\n    /** Georgian */\n    ka = 'ka',\n    /** German */\n    de = 'de',\n    /** Austrian German */\n    de_AT = 'de_AT',\n    /** Swiss High German */\n    de_CH = 'de_CH',\n    /** Greek */\n    el = 'el',\n    /** Gujarati */\n    gu = 'gu',\n    /** Haitian Creole */\n    ht = 'ht',\n    /** Hausa */\n    ha = 'ha',\n    /** Hebrew */\n    he = 'he',\n    /** Hindi */\n    hi = 'hi',\n    /** Hungarian */\n    hu = 'hu',\n    /** Icelandic */\n    is = 'is',\n    /** Igbo */\n    ig = 'ig',\n    /** Indonesian */\n    id = 'id',\n    /** Interlingua */\n    ia = 'ia',\n    /** Irish */\n    ga = 'ga',\n    /** Italian */\n    it = 'it',\n    /** Japanese */\n    ja = 'ja',\n    /** Javanese */\n    jv = 'jv',\n    /** Kalaallisut */\n    kl = 'kl',\n    /** Kannada */\n    kn = 'kn',\n    /** Kashmiri */\n    ks = 'ks',\n    /** Kazakh */\n    kk = 'kk',\n    /** Khmer */\n    km = 'km',\n    /** Kikuyu */\n    ki = 'ki',\n    /** Kinyarwanda */\n    rw = 'rw',\n    /** Korean */\n    ko = 'ko',\n    /** Kurdish */\n    ku = 'ku',\n    /** Kyrgyz */\n    ky = 'ky',\n    /** Lao */\n    lo = 'lo',\n    /** Latin */\n    la = 'la',\n    /** Latvian */\n    lv = 'lv',\n    /** Lingala */\n    ln = 'ln',\n    /** Lithuanian */\n    lt = 'lt',\n    /** Luba-Katanga */\n    lu = 'lu',\n    /** Luxembourgish */\n    lb = 'lb',\n    /** Macedonian */\n    mk = 'mk',\n    /** Malagasy */\n    mg = 'mg',\n    /** Malay */\n    ms = 'ms',\n    /** Malayalam */\n    ml = 'ml',\n    /** Maltese */\n    mt = 'mt',\n    /** Manx */\n    gv = 'gv',\n    /** Maori */\n    mi = 'mi',\n    /** Marathi */\n    mr = 'mr',\n    /** Mongolian */\n    mn = 'mn',\n    /** Nepali */\n    ne = 'ne',\n    /** North Ndebele */\n    nd = 'nd',\n    /** Northern Sami */\n    se = 'se',\n    /** Norwegian Bokmål */\n    nb = 'nb',\n    /** Norwegian Nynorsk */\n    nn = 'nn',\n    /** Nyanja */\n    ny = 'ny',\n    /** Odia */\n    or = 'or',\n    /** Oromo */\n    om = 'om',\n    /** Ossetic */\n    os = 'os',\n    /** Pashto */\n    ps = 'ps',\n    /** Persian */\n    fa = 'fa',\n    /** Dari */\n    fa_AF = 'fa_AF',\n    /** Polish */\n    pl = 'pl',\n    /** Portuguese */\n    pt = 'pt',\n    /** Brazilian Portuguese */\n    pt_BR = 'pt_BR',\n    /** European Portuguese */\n    pt_PT = 'pt_PT',\n    /** Punjabi */\n    pa = 'pa',\n    /** Quechua */\n    qu = 'qu',\n    /** Romanian */\n    ro = 'ro',\n    /** Moldavian */\n    ro_MD = 'ro_MD',\n    /** Romansh */\n    rm = 'rm',\n    /** Rundi */\n    rn = 'rn',\n    /** Russian */\n    ru = 'ru',\n    /** Samoan */\n    sm = 'sm',\n    /** Sango */\n    sg = 'sg',\n    /** Sanskrit */\n    sa = 'sa',\n    /** Scottish Gaelic */\n    gd = 'gd',\n    /** Serbian */\n    sr = 'sr',\n    /** Shona */\n    sn = 'sn',\n    /** Sichuan Yi */\n    ii = 'ii',\n    /** Sindhi */\n    sd = 'sd',\n    /** Sinhala */\n    si = 'si',\n    /** Slovak */\n    sk = 'sk',\n    /** Slovenian */\n    sl = 'sl',\n    /** Somali */\n    so = 'so',\n    /** Southern Sotho */\n    st = 'st',\n    /** Spanish */\n    es = 'es',\n    /** European Spanish */\n    es_ES = 'es_ES',\n    /** Mexican Spanish */\n    es_MX = 'es_MX',\n    /** Sundanese */\n    su = 'su',\n    /** Swahili */\n    sw = 'sw',\n    /** Congo Swahili */\n    sw_CD = 'sw_CD',\n    /** Swedish */\n    sv = 'sv',\n    /** Tajik */\n    tg = 'tg',\n    /** Tamil */\n    ta = 'ta',\n    /** Tatar */\n    tt = 'tt',\n    /** Telugu */\n    te = 'te',\n    /** Thai */\n    th = 'th',\n    /** Tibetan */\n    bo = 'bo',\n    /** Tigrinya */\n    ti = 'ti',\n    /** Tongan */\n    to = 'to',\n    /** Turkish */\n    tr = 'tr',\n    /** Turkmen */\n    tk = 'tk',\n    /** Ukrainian */\n    uk = 'uk',\n    /** Urdu */\n    ur = 'ur',\n    /** Uyghur */\n    ug = 'ug',\n    /** Uzbek */\n    uz = 'uz',\n    /** Vietnamese */\n    vi = 'vi',\n    /** Volapük */\n    vo = 'vo',\n    /** Welsh */\n    cy = 'cy',\n    /** Western Frisian */\n    fy = 'fy',\n    /** Wolof */\n    wo = 'wo',\n    /** Xhosa */\n    xh = 'xh',\n    /** Yiddish */\n    yi = 'yi',\n    /** Yoruba */\n    yo = 'yo',\n    /** Zulu */\n    zu = 'zu',\n}\n\nexport type LocaleStringCustomFieldConfig = CustomField & {\n    __typename?: 'LocaleStringCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    length?: Maybe<Scalars['Int']>;\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    pattern?: Maybe<Scalars['String']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type LocalizedString = {\n    __typename?: 'LocalizedString';\n    languageCode: LanguageCode;\n    value: Scalars['String'];\n};\n\nexport enum LogicalOperator {\n    AND = 'AND',\n    OR = 'OR',\n}\n\n/** Returned when attempting to register or verify a customer account without a password, when one is required. */\nexport type MissingPasswordError = ErrorResult & {\n    __typename?: 'MissingPasswordError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type Mutation = {\n    __typename?: 'Mutation';\n    /** Adds an item to the order. If custom fields are defined on the OrderLine entity, a third argument 'customFields' will be available. */\n    addItemToOrder: UpdateOrderItemsResult;\n    /** Remove an OrderLine from the Order */\n    removeOrderLine: RemoveOrderItemsResult;\n    /** Remove all OrderLine from the Order */\n    removeAllOrderLines: RemoveOrderItemsResult;\n    /** Adjusts an OrderLine. If custom fields are defined on the OrderLine entity, a third argument 'customFields' of type `OrderLineCustomFieldsInput` will be available. */\n    adjustOrderLine: UpdateOrderItemsResult;\n    /** Applies the given coupon code to the active Order */\n    applyCouponCode: ApplyCouponCodeResult;\n    /** Removes the given coupon code from the active Order */\n    removeCouponCode?: Maybe<Order>;\n    /** Transitions an Order to a new state. Valid next states can be found by querying `nextOrderStates` */\n    transitionOrderToState?: Maybe<TransitionOrderToStateResult>;\n    /** Sets the shipping address for this order */\n    setOrderShippingAddress: ActiveOrderResult;\n    /** Sets the billing address for this order */\n    setOrderBillingAddress: ActiveOrderResult;\n    /** Allows any custom fields to be set for the active order */\n    setOrderCustomFields: ActiveOrderResult;\n    /** Sets the shipping method by id, which can be obtained with the `eligibleShippingMethods` query */\n    setOrderShippingMethod: SetOrderShippingMethodResult;\n    /** Add a Payment to the Order */\n    addPaymentToOrder: AddPaymentToOrderResult;\n    /** Set the Customer for the Order. Required only if the Customer is not currently logged in */\n    setCustomerForOrder: SetCustomerForOrderResult;\n    /** Authenticates the user using the native authentication strategy. This mutation is an alias for `authenticate({ native: { ... }})` */\n    login: NativeAuthenticationResult;\n    /** Authenticates the user using a named authentication strategy */\n    authenticate: AuthenticationResult;\n    /** End the current authenticated session */\n    logout: Success;\n    /**\n     * Register a Customer account with the given credentials. There are three possible registration flows:\n     *\n     * _If `authOptions.requireVerification` is set to `true`:_\n     *\n     * 1. **The Customer is registered _with_ a password**. A verificationToken will be created (and typically emailed to the Customer). That\n     *    verificationToken would then be passed to the `verifyCustomerAccount` mutation _without_ a password. The Customer is then\n     *    verified and authenticated in one step.\n     * 2. **The Customer is registered _without_ a password**. A verificationToken will be created (and typically emailed to the Customer). That\n     *    verificationToken would then be passed to the `verifyCustomerAccount` mutation _with_ the chosen password of the Customer. The Customer is then\n     *    verified and authenticated in one step.\n     *\n     * _If `authOptions.requireVerification` is set to `false`:_\n     *\n     * 3. The Customer _must_ be registered _with_ a password. No further action is needed - the Customer is able to authenticate immediately.\n     */\n    registerCustomerAccount: RegisterCustomerAccountResult;\n    /** Regenerate and send a verification token for a new Customer registration. Only applicable if `authOptions.requireVerification` is set to true. */\n    refreshCustomerVerification: RefreshCustomerVerificationResult;\n    /** Update an existing Customer */\n    updateCustomer: Customer;\n    /** Create a new Customer Address */\n    createCustomerAddress: Address;\n    /** Update an existing Address */\n    updateCustomerAddress: Address;\n    /** Delete an existing Address */\n    deleteCustomerAddress: Success;\n    /**\n     * Verify a Customer email address with the token sent to that address. Only applicable if `authOptions.requireVerification` is set to true.\n     *\n     * If the Customer was not registered with a password in the `registerCustomerAccount` mutation, the password _must_ be\n     * provided here.\n     */\n    verifyCustomerAccount: VerifyCustomerAccountResult;\n    /** Update the password of the active Customer */\n    updateCustomerPassword: UpdateCustomerPasswordResult;\n    /**\n     * Request to update the emailAddress of the active Customer. If `authOptions.requireVerification` is enabled\n     * (as is the default), then the `identifierChangeToken` will be assigned to the current User and\n     * a IdentifierChangeRequestEvent will be raised. This can then be used e.g. by the EmailPlugin to email\n     * that verification token to the Customer, which is then used to verify the change of email address.\n     */\n    requestUpdateCustomerEmailAddress: RequestUpdateCustomerEmailAddressResult;\n    /**\n     * Confirm the update of the emailAddress with the provided token, which has been generated by the\n     * `requestUpdateCustomerEmailAddress` mutation.\n     */\n    updateCustomerEmailAddress: UpdateCustomerEmailAddressResult;\n    /** Requests a password reset email to be sent */\n    requestPasswordReset?: Maybe<RequestPasswordResetResult>;\n    /** Resets a Customer's password based on the provided token */\n    resetPassword: ResetPasswordResult;\n};\n\nexport type MutationAddItemToOrderArgs = {\n    productVariantId: Scalars['ID'];\n    quantity: Scalars['Int'];\n};\n\nexport type MutationRemoveOrderLineArgs = {\n    orderLineId: Scalars['ID'];\n};\n\nexport type MutationAdjustOrderLineArgs = {\n    orderLineId: Scalars['ID'];\n    quantity: Scalars['Int'];\n};\n\nexport type MutationApplyCouponCodeArgs = {\n    couponCode: Scalars['String'];\n};\n\nexport type MutationRemoveCouponCodeArgs = {\n    couponCode: Scalars['String'];\n};\n\nexport type MutationTransitionOrderToStateArgs = {\n    state: Scalars['String'];\n};\n\nexport type MutationSetOrderShippingAddressArgs = {\n    input: CreateAddressInput;\n};\n\nexport type MutationSetOrderBillingAddressArgs = {\n    input: CreateAddressInput;\n};\n\nexport type MutationSetOrderCustomFieldsArgs = {\n    input: UpdateOrderInput;\n};\n\nexport type MutationSetOrderShippingMethodArgs = {\n    shippingMethodId: Scalars['ID'];\n};\n\nexport type MutationAddPaymentToOrderArgs = {\n    input: PaymentInput;\n};\n\nexport type MutationSetCustomerForOrderArgs = {\n    input: CreateCustomerInput;\n};\n\nexport type MutationLoginArgs = {\n    username: Scalars['String'];\n    password: Scalars['String'];\n    rememberMe?: Maybe<Scalars['Boolean']>;\n};\n\nexport type MutationAuthenticateArgs = {\n    input: AuthenticationInput;\n    rememberMe?: Maybe<Scalars['Boolean']>;\n};\n\nexport type MutationRegisterCustomerAccountArgs = {\n    input: RegisterCustomerInput;\n};\n\nexport type MutationRefreshCustomerVerificationArgs = {\n    emailAddress: Scalars['String'];\n};\n\nexport type MutationUpdateCustomerArgs = {\n    input: UpdateCustomerInput;\n};\n\nexport type MutationCreateCustomerAddressArgs = {\n    input: CreateAddressInput;\n};\n\nexport type MutationUpdateCustomerAddressArgs = {\n    input: UpdateAddressInput;\n};\n\nexport type MutationDeleteCustomerAddressArgs = {\n    id: Scalars['ID'];\n};\n\nexport type MutationVerifyCustomerAccountArgs = {\n    token: Scalars['String'];\n    password?: Maybe<Scalars['String']>;\n};\n\nexport type MutationUpdateCustomerPasswordArgs = {\n    currentPassword: Scalars['String'];\n    newPassword: Scalars['String'];\n};\n\nexport type MutationRequestUpdateCustomerEmailAddressArgs = {\n    password: Scalars['String'];\n    newEmailAddress: Scalars['String'];\n};\n\nexport type MutationUpdateCustomerEmailAddressArgs = {\n    token: Scalars['String'];\n};\n\nexport type MutationRequestPasswordResetArgs = {\n    emailAddress: Scalars['String'];\n};\n\nexport type MutationResetPasswordArgs = {\n    token: Scalars['String'];\n    password: Scalars['String'];\n};\n\nexport type NativeAuthInput = {\n    username: Scalars['String'];\n    password: Scalars['String'];\n};\n\n/** Returned when attempting an operation that relies on the NativeAuthStrategy, if that strategy is not configured. */\nexport type NativeAuthStrategyError = ErrorResult & {\n    __typename?: 'NativeAuthStrategyError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type NativeAuthenticationResult =\n    | CurrentUser\n    | InvalidCredentialsError\n    | NotVerifiedError\n    | NativeAuthStrategyError;\n\n/** Returned when attempting to set a negative OrderLine quantity. */\nexport type NegativeQuantityError = ErrorResult & {\n    __typename?: 'NegativeQuantityError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/**\n * Returned when invoking a mutation which depends on there being an active Order on the\n * current session.\n */\nexport type NoActiveOrderError = ErrorResult & {\n    __typename?: 'NoActiveOrderError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type Node = {\n    id: Scalars['ID'];\n};\n\n/**\n * Returned if `authOptions.requireVerification` is set to `true` (which is the default)\n * and an unverified user attempts to authenticate.\n */\nexport type NotVerifiedError = ErrorResult & {\n    __typename?: 'NotVerifiedError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/** Operators for filtering on a list of Number fields */\nexport type NumberListOperators = {\n    inList: Scalars['Float'];\n};\n\n/** Operators for filtering on a Int or Float field */\nexport type NumberOperators = {\n    eq?: Maybe<Scalars['Float']>;\n    lt?: Maybe<Scalars['Float']>;\n    lte?: Maybe<Scalars['Float']>;\n    gt?: Maybe<Scalars['Float']>;\n    gte?: Maybe<Scalars['Float']>;\n    between?: Maybe<NumberRange>;\n};\n\nexport type NumberRange = {\n    start: Scalars['Float'];\n    end: Scalars['Float'];\n};\n\nexport type Order = Node & {\n    __typename?: 'Order';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    /**\n     * The date & time that the Order was placed, i.e. the Customer\n     * completed the checkout and the Order is no longer \"active\"\n     */\n    orderPlacedAt?: Maybe<Scalars['DateTime']>;\n    /** A unique code for the Order */\n    code: Scalars['String'];\n    state: Scalars['String'];\n    /** An order is active as long as the payment process has not been completed */\n    active: Scalars['Boolean'];\n    customer?: Maybe<Customer>;\n    shippingAddress?: Maybe<OrderAddress>;\n    billingAddress?: Maybe<OrderAddress>;\n    lines: Array<OrderLine>;\n    /**\n     * Surcharges are arbitrary modifications to the Order total which are neither\n     * ProductVariants nor discounts resulting from applied Promotions. For example,\n     * one-off discounts based on customer interaction, or surcharges based on payment\n     * methods.\n     */\n    surcharges: Array<Surcharge>;\n    discounts: Array<Discount>;\n    /** An array of all coupon codes applied to the Order */\n    couponCodes: Array<Scalars['String']>;\n    /** Promotions applied to the order. Only gets populated after the payment process has completed. */\n    promotions: Array<Promotion>;\n    payments?: Maybe<Array<Payment>>;\n    fulfillments?: Maybe<Array<Fulfillment>>;\n    totalQuantity: Scalars['Int'];\n    /**\n     * The subTotal is the total of all OrderLines in the Order. This figure also includes any Order-level\n     * discounts which have been prorated (proportionally distributed) amongst the OrderItems.\n     * To get a total of all OrderLines which does not account for prorated discounts, use the\n     * sum of `OrderLine.discountedLinePrice` values.\n     */\n    subTotal: Scalars['Int'];\n    /** Same as subTotal, but inclusive of tax */\n    subTotalWithTax: Scalars['Int'];\n    currencyCode: CurrencyCode;\n    shippingLines: Array<ShippingLine>;\n    shipping: Scalars['Int'];\n    shippingWithTax: Scalars['Int'];\n    /** Equal to subTotal plus shipping */\n    total: Scalars['Int'];\n    /** The final payable amount. Equal to subTotalWithTax plus shippingWithTax */\n    totalWithTax: Scalars['Int'];\n    /** A summary of the taxes being applied to this Order */\n    taxSummary: Array<OrderTaxSummary>;\n    history: HistoryEntryList;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type OrderHistoryArgs = {\n    options?: Maybe<HistoryEntryListOptions>;\n};\n\nexport type OrderAddress = {\n    __typename?: 'OrderAddress';\n    fullName?: Maybe<Scalars['String']>;\n    company?: Maybe<Scalars['String']>;\n    streetLine1?: Maybe<Scalars['String']>;\n    streetLine2?: Maybe<Scalars['String']>;\n    city?: Maybe<Scalars['String']>;\n    province?: Maybe<Scalars['String']>;\n    postalCode?: Maybe<Scalars['String']>;\n    country?: Maybe<Scalars['String']>;\n    countryCode?: Maybe<Scalars['String']>;\n    phoneNumber?: Maybe<Scalars['String']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type OrderFilterParameter = {\n    id?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    orderPlacedAt?: Maybe<DateOperators>;\n    code?: Maybe<StringOperators>;\n    state?: Maybe<StringOperators>;\n    active?: Maybe<BooleanOperators>;\n    totalQuantity?: Maybe<NumberOperators>;\n    subTotal?: Maybe<NumberOperators>;\n    subTotalWithTax?: Maybe<NumberOperators>;\n    currencyCode?: Maybe<StringOperators>;\n    shipping?: Maybe<NumberOperators>;\n    shippingWithTax?: Maybe<NumberOperators>;\n    total?: Maybe<NumberOperators>;\n    totalWithTax?: Maybe<NumberOperators>;\n};\n\nexport type OrderItem = Node & {\n    __typename?: 'OrderItem';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    cancelled: Scalars['Boolean'];\n    /** The price of a single unit, excluding tax and discounts */\n    unitPrice: Scalars['Int'];\n    /** The price of a single unit, including tax but excluding discounts */\n    unitPriceWithTax: Scalars['Int'];\n    /**\n     * The price of a single unit including discounts, excluding tax.\n     *\n     * If Order-level discounts have been applied, this will not be the\n     * actual taxable unit price (see `proratedUnitPrice`), but is generally the\n     * correct price to display to customers to avoid confusion\n     * about the internal handling of distributed Order-level discounts.\n     */\n    discountedUnitPrice: Scalars['Int'];\n    /** The price of a single unit including discounts and tax */\n    discountedUnitPriceWithTax: Scalars['Int'];\n    /**\n     * The actual unit price, taking into account both item discounts _and_ prorated (proportionally-distributed)\n     * Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax\n     * and refund calculations.\n     */\n    proratedUnitPrice: Scalars['Int'];\n    /** The proratedUnitPrice including tax */\n    proratedUnitPriceWithTax: Scalars['Int'];\n    unitTax: Scalars['Int'];\n    taxRate: Scalars['Float'];\n    adjustments: Array<Adjustment>;\n    taxLines: Array<TaxLine>;\n    fulfillment?: Maybe<Fulfillment>;\n    refundId?: Maybe<Scalars['ID']>;\n};\n\n/** Returned when the maximum order size limit has been reached. */\nexport type OrderLimitError = ErrorResult & {\n    __typename?: 'OrderLimitError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    maxItems: Scalars['Int'];\n};\n\nexport type OrderLine = Node & {\n    __typename?: 'OrderLine';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    productVariant: ProductVariant;\n    featuredAsset?: Maybe<Asset>;\n    /** The price of a single unit, excluding tax and discounts */\n    unitPrice: Scalars['Int'];\n    /** The price of a single unit, including tax but excluding discounts */\n    unitPriceWithTax: Scalars['Int'];\n    /** Non-zero if the unitPrice has changed since it was initially added to Order */\n    unitPriceChangeSinceAdded: Scalars['Int'];\n    /** Non-zero if the unitPriceWithTax has changed since it was initially added to Order */\n    unitPriceWithTaxChangeSinceAdded: Scalars['Int'];\n    /**\n     * The price of a single unit including discounts, excluding tax.\n     *\n     * If Order-level discounts have been applied, this will not be the\n     * actual taxable unit price (see `proratedUnitPrice`), but is generally the\n     * correct price to display to customers to avoid confusion\n     * about the internal handling of distributed Order-level discounts.\n     */\n    discountedUnitPrice: Scalars['Int'];\n    /** The price of a single unit including discounts and tax */\n    discountedUnitPriceWithTax: Scalars['Int'];\n    /**\n     * The actual unit price, taking into account both item discounts _and_ prorated (proportionally-distributed)\n     * Order-level discounts. This value is the true economic value of the OrderItem, and is used in tax\n     * and refund calculations.\n     */\n    proratedUnitPrice: Scalars['Int'];\n    /** The proratedUnitPrice including tax */\n    proratedUnitPriceWithTax: Scalars['Int'];\n    quantity: Scalars['Int'];\n    items: Array<OrderItem>;\n    taxRate: Scalars['Float'];\n    /** The total price of the line excluding tax and discounts. */\n    linePrice: Scalars['Int'];\n    /** The total price of the line including tax but excluding discounts. */\n    linePriceWithTax: Scalars['Int'];\n    /** The price of the line including discounts, excluding tax */\n    discountedLinePrice: Scalars['Int'];\n    /** The price of the line including discounts and tax */\n    discountedLinePriceWithTax: Scalars['Int'];\n    /**\n     * The actual line price, taking into account both item discounts _and_ prorated (proportionally-distributed)\n     * Order-level discounts. This value is the true economic value of the OrderLine, and is used in tax\n     * and refund calculations.\n     */\n    proratedLinePrice: Scalars['Int'];\n    /** The proratedLinePrice including tax */\n    proratedLinePriceWithTax: Scalars['Int'];\n    /** The total tax on this line */\n    lineTax: Scalars['Int'];\n    discounts: Array<Discount>;\n    taxLines: Array<TaxLine>;\n    order: Order;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type OrderList = PaginatedList & {\n    __typename?: 'OrderList';\n    items: Array<Order>;\n    totalItems: Scalars['Int'];\n};\n\nexport type OrderListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<OrderSortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<OrderFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\n/** Returned when attempting to modify the contents of an Order that is not in the `AddingItems` state. */\nexport type OrderModificationError = ErrorResult & {\n    __typename?: 'OrderModificationError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/** Returned when attempting to add a Payment to an Order that is not in the `ArrangingPayment` state. */\nexport type OrderPaymentStateError = ErrorResult & {\n    __typename?: 'OrderPaymentStateError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type OrderSortParameter = {\n    id?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n    orderPlacedAt?: Maybe<SortOrder>;\n    code?: Maybe<SortOrder>;\n    state?: Maybe<SortOrder>;\n    totalQuantity?: Maybe<SortOrder>;\n    subTotal?: Maybe<SortOrder>;\n    subTotalWithTax?: Maybe<SortOrder>;\n    shipping?: Maybe<SortOrder>;\n    shippingWithTax?: Maybe<SortOrder>;\n    total?: Maybe<SortOrder>;\n    totalWithTax?: Maybe<SortOrder>;\n};\n\n/** Returned if there is an error in transitioning the Order state */\nexport type OrderStateTransitionError = ErrorResult & {\n    __typename?: 'OrderStateTransitionError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    transitionError: Scalars['String'];\n    fromState: Scalars['String'];\n    toState: Scalars['String'];\n};\n\n/**\n * A summary of the taxes being applied to this order, grouped\n * by taxRate.\n */\nexport type OrderTaxSummary = {\n    __typename?: 'OrderTaxSummary';\n    /** A description of this tax */\n    description: Scalars['String'];\n    /** The taxRate as a percentage */\n    taxRate: Scalars['Float'];\n    /** The total net price or OrderItems to which this taxRate applies */\n    taxBase: Scalars['Int'];\n    /** The total tax being applied to the Order at this taxRate */\n    taxTotal: Scalars['Int'];\n};\n\nexport type PaginatedList = {\n    items: Array<Node>;\n    totalItems: Scalars['Int'];\n};\n\n/** Returned when attempting to verify a customer account with a password, when a password has already been set. */\nexport type PasswordAlreadySetError = ErrorResult & {\n    __typename?: 'PasswordAlreadySetError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/**\n * Returned if the token used to reset a Customer's password is valid, but has\n * expired according to the `verificationTokenDuration` setting in the AuthOptions.\n */\nexport type PasswordResetTokenExpiredError = ErrorResult & {\n    __typename?: 'PasswordResetTokenExpiredError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/**\n * Returned if the token used to reset a Customer's password is either\n * invalid or does not match any expected tokens.\n */\nexport type PasswordResetTokenInvalidError = ErrorResult & {\n    __typename?: 'PasswordResetTokenInvalidError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/** Returned when attempting to register or verify a customer account where the given password fails password validation. */\nexport type PasswordValidationError = ErrorResult & {\n    __typename?: 'PasswordValidationError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    validationErrorMessage: Scalars['String'];\n};\n\nexport type Payment = Node & {\n    __typename?: 'Payment';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    method: Scalars['String'];\n    amount: Scalars['Int'];\n    state: Scalars['String'];\n    transactionId?: Maybe<Scalars['String']>;\n    errorMessage?: Maybe<Scalars['String']>;\n    refunds: Array<Refund>;\n    metadata?: Maybe<Scalars['JSON']>;\n};\n\n/** Returned when a Payment is declined by the payment provider. */\nexport type PaymentDeclinedError = ErrorResult & {\n    __typename?: 'PaymentDeclinedError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    paymentErrorMessage: Scalars['String'];\n};\n\n/** Returned when a Payment fails due to an error. */\nexport type PaymentFailedError = ErrorResult & {\n    __typename?: 'PaymentFailedError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n    paymentErrorMessage: Scalars['String'];\n};\n\n/** Passed as input to the `addPaymentToOrder` mutation. */\nexport type PaymentInput = {\n    /** This field should correspond to the `code` property of a PaymentMethod. */\n    method: Scalars['String'];\n    /**\n     * This field should contain arbitrary data passed to the specified PaymentMethodHandler's `createPayment()` method\n     * as the \"metadata\" argument. For example, it could contain an ID for the payment and other\n     * data generated by the payment provider.\n     */\n    metadata: Scalars['JSON'];\n};\n\nexport type PaymentMethod = Node & {\n    __typename?: 'PaymentMethod';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    name: Scalars['String'];\n    code: Scalars['String'];\n    description: Scalars['String'];\n    enabled: Scalars['Boolean'];\n    checker?: Maybe<ConfigurableOperation>;\n    handler: ConfigurableOperation;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type PaymentMethodQuote = {\n    __typename?: 'PaymentMethodQuote';\n    id: Scalars['ID'];\n    code: Scalars['String'];\n    name: Scalars['String'];\n    description: Scalars['String'];\n    isEligible: Scalars['Boolean'];\n    eligibilityMessage?: Maybe<Scalars['String']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\n/**\n * @description\n * Permissions for administrators and customers. Used to control access to\n * GraphQL resolvers via the {@link Allow} decorator.\n *\n * ## Understanding Permission.Owner\n *\n * `Permission.Owner` is a special permission which is used in some of the Vendure resolvers to indicate that that resolver should only\n * be accessible to the \"owner\" of that resource.\n *\n * For example, the Shop API `activeCustomer` query resolver should only return the Customer object for the \"owner\" of that Customer, i.e.\n * based on the activeUserId of the current session. As a result, the resolver code looks like this:\n *\n * @example\n * ```TypeScript\n * \\@Query()\n * \\@Allow(Permission.Owner)\n * async activeCustomer(\\@Ctx() ctx: RequestContext): Promise<Customer | undefined> {\n *   const userId = ctx.activeUserId;\n *   if (userId) {\n *     return this.customerService.findOneByUserId(ctx, userId);\n *   }\n * }\n * ```\n *\n * Here we can see that the \"ownership\" must be enforced by custom logic inside the resolver. Since \"ownership\" cannot be defined generally\n * nor statically encoded at build-time, any resolvers using `Permission.Owner` **must** include logic to enforce that only the owner\n * of the resource has access. If not, then it is the equivalent of using `Permission.Public`.\n *\n *\n * @docsCategory common\n */\nexport enum Permission {\n    /** Authenticated means simply that the user is logged in */\n    Authenticated = 'Authenticated',\n    /** SuperAdmin has unrestricted access to all operations */\n    SuperAdmin = 'SuperAdmin',\n    /** Owner means the user owns this entity, e.g. a Customer's own Order */\n    Owner = 'Owner',\n    /** Public means any unauthenticated user may perform the operation */\n    Public = 'Public',\n    /** Grants permission to update GlobalSettings */\n    UpdateGlobalSettings = 'UpdateGlobalSettings',\n    /** Grants permission to create Products, Facets, Assets, Collections */\n    CreateCatalog = 'CreateCatalog',\n    /** Grants permission to read Products, Facets, Assets, Collections */\n    ReadCatalog = 'ReadCatalog',\n    /** Grants permission to update Products, Facets, Assets, Collections */\n    UpdateCatalog = 'UpdateCatalog',\n    /** Grants permission to delete Products, Facets, Assets, Collections */\n    DeleteCatalog = 'DeleteCatalog',\n    /** Grants permission to create PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\n    CreateSettings = 'CreateSettings',\n    /** Grants permission to read PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\n    ReadSettings = 'ReadSettings',\n    /** Grants permission to update PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\n    UpdateSettings = 'UpdateSettings',\n    /** Grants permission to delete PaymentMethods, ShippingMethods, TaxCategories, TaxRates, Zones, Countries, System & GlobalSettings */\n    DeleteSettings = 'DeleteSettings',\n    /** Grants permission to create Administrator */\n    CreateAdministrator = 'CreateAdministrator',\n    /** Grants permission to read Administrator */\n    ReadAdministrator = 'ReadAdministrator',\n    /** Grants permission to update Administrator */\n    UpdateAdministrator = 'UpdateAdministrator',\n    /** Grants permission to delete Administrator */\n    DeleteAdministrator = 'DeleteAdministrator',\n    /** Grants permission to create Asset */\n    CreateAsset = 'CreateAsset',\n    /** Grants permission to read Asset */\n    ReadAsset = 'ReadAsset',\n    /** Grants permission to update Asset */\n    UpdateAsset = 'UpdateAsset',\n    /** Grants permission to delete Asset */\n    DeleteAsset = 'DeleteAsset',\n    /** Grants permission to create Channel */\n    CreateChannel = 'CreateChannel',\n    /** Grants permission to read Channel */\n    ReadChannel = 'ReadChannel',\n    /** Grants permission to update Channel */\n    UpdateChannel = 'UpdateChannel',\n    /** Grants permission to delete Channel */\n    DeleteChannel = 'DeleteChannel',\n    /** Grants permission to create Collection */\n    CreateCollection = 'CreateCollection',\n    /** Grants permission to read Collection */\n    ReadCollection = 'ReadCollection',\n    /** Grants permission to update Collection */\n    UpdateCollection = 'UpdateCollection',\n    /** Grants permission to delete Collection */\n    DeleteCollection = 'DeleteCollection',\n    /** Grants permission to create Country */\n    CreateCountry = 'CreateCountry',\n    /** Grants permission to read Country */\n    ReadCountry = 'ReadCountry',\n    /** Grants permission to update Country */\n    UpdateCountry = 'UpdateCountry',\n    /** Grants permission to delete Country */\n    DeleteCountry = 'DeleteCountry',\n    /** Grants permission to create Customer */\n    CreateCustomer = 'CreateCustomer',\n    /** Grants permission to read Customer */\n    ReadCustomer = 'ReadCustomer',\n    /** Grants permission to update Customer */\n    UpdateCustomer = 'UpdateCustomer',\n    /** Grants permission to delete Customer */\n    DeleteCustomer = 'DeleteCustomer',\n    /** Grants permission to create CustomerGroup */\n    CreateCustomerGroup = 'CreateCustomerGroup',\n    /** Grants permission to read CustomerGroup */\n    ReadCustomerGroup = 'ReadCustomerGroup',\n    /** Grants permission to update CustomerGroup */\n    UpdateCustomerGroup = 'UpdateCustomerGroup',\n    /** Grants permission to delete CustomerGroup */\n    DeleteCustomerGroup = 'DeleteCustomerGroup',\n    /** Grants permission to create Facet */\n    CreateFacet = 'CreateFacet',\n    /** Grants permission to read Facet */\n    ReadFacet = 'ReadFacet',\n    /** Grants permission to update Facet */\n    UpdateFacet = 'UpdateFacet',\n    /** Grants permission to delete Facet */\n    DeleteFacet = 'DeleteFacet',\n    /** Grants permission to create Order */\n    CreateOrder = 'CreateOrder',\n    /** Grants permission to read Order */\n    ReadOrder = 'ReadOrder',\n    /** Grants permission to update Order */\n    UpdateOrder = 'UpdateOrder',\n    /** Grants permission to delete Order */\n    DeleteOrder = 'DeleteOrder',\n    /** Grants permission to create PaymentMethod */\n    CreatePaymentMethod = 'CreatePaymentMethod',\n    /** Grants permission to read PaymentMethod */\n    ReadPaymentMethod = 'ReadPaymentMethod',\n    /** Grants permission to update PaymentMethod */\n    UpdatePaymentMethod = 'UpdatePaymentMethod',\n    /** Grants permission to delete PaymentMethod */\n    DeletePaymentMethod = 'DeletePaymentMethod',\n    /** Grants permission to create Product */\n    CreateProduct = 'CreateProduct',\n    /** Grants permission to read Product */\n    ReadProduct = 'ReadProduct',\n    /** Grants permission to update Product */\n    UpdateProduct = 'UpdateProduct',\n    /** Grants permission to delete Product */\n    DeleteProduct = 'DeleteProduct',\n    /** Grants permission to create Promotion */\n    CreatePromotion = 'CreatePromotion',\n    /** Grants permission to read Promotion */\n    ReadPromotion = 'ReadPromotion',\n    /** Grants permission to update Promotion */\n    UpdatePromotion = 'UpdatePromotion',\n    /** Grants permission to delete Promotion */\n    DeletePromotion = 'DeletePromotion',\n    /** Grants permission to create ShippingMethod */\n    CreateShippingMethod = 'CreateShippingMethod',\n    /** Grants permission to read ShippingMethod */\n    ReadShippingMethod = 'ReadShippingMethod',\n    /** Grants permission to update ShippingMethod */\n    UpdateShippingMethod = 'UpdateShippingMethod',\n    /** Grants permission to delete ShippingMethod */\n    DeleteShippingMethod = 'DeleteShippingMethod',\n    /** Grants permission to create Tag */\n    CreateTag = 'CreateTag',\n    /** Grants permission to read Tag */\n    ReadTag = 'ReadTag',\n    /** Grants permission to update Tag */\n    UpdateTag = 'UpdateTag',\n    /** Grants permission to delete Tag */\n    DeleteTag = 'DeleteTag',\n    /** Grants permission to create TaxCategory */\n    CreateTaxCategory = 'CreateTaxCategory',\n    /** Grants permission to read TaxCategory */\n    ReadTaxCategory = 'ReadTaxCategory',\n    /** Grants permission to update TaxCategory */\n    UpdateTaxCategory = 'UpdateTaxCategory',\n    /** Grants permission to delete TaxCategory */\n    DeleteTaxCategory = 'DeleteTaxCategory',\n    /** Grants permission to create TaxRate */\n    CreateTaxRate = 'CreateTaxRate',\n    /** Grants permission to read TaxRate */\n    ReadTaxRate = 'ReadTaxRate',\n    /** Grants permission to update TaxRate */\n    UpdateTaxRate = 'UpdateTaxRate',\n    /** Grants permission to delete TaxRate */\n    DeleteTaxRate = 'DeleteTaxRate',\n    /** Grants permission to create System */\n    CreateSystem = 'CreateSystem',\n    /** Grants permission to read System */\n    ReadSystem = 'ReadSystem',\n    /** Grants permission to update System */\n    UpdateSystem = 'UpdateSystem',\n    /** Grants permission to delete System */\n    DeleteSystem = 'DeleteSystem',\n    /** Grants permission to create Zone */\n    CreateZone = 'CreateZone',\n    /** Grants permission to read Zone */\n    ReadZone = 'ReadZone',\n    /** Grants permission to update Zone */\n    UpdateZone = 'UpdateZone',\n    /** Grants permission to delete Zone */\n    DeleteZone = 'DeleteZone',\n}\n\n/** The price range where the result has more than one price */\nexport type PriceRange = {\n    __typename?: 'PriceRange';\n    min: Scalars['Int'];\n    max: Scalars['Int'];\n};\n\nexport type Product = Node & {\n    __typename?: 'Product';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n    slug: Scalars['String'];\n    description: Scalars['String'];\n    featuredAsset?: Maybe<Asset>;\n    assets: Array<Asset>;\n    /** Returns all ProductVariants */\n    variants: Array<ProductVariant>;\n    /** Returns a paginated, sortable, filterable list of ProductVariants */\n    variantList: ProductVariantList;\n    optionGroups: Array<ProductOptionGroup>;\n    facetValues: Array<FacetValue>;\n    translations: Array<ProductTranslation>;\n    collections: Array<Collection>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type ProductVariantListArgs = {\n    options?: Maybe<ProductVariantListOptions>;\n};\n\nexport type ProductFilterParameter = {\n    id?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    languageCode?: Maybe<StringOperators>;\n    name?: Maybe<StringOperators>;\n    slug?: Maybe<StringOperators>;\n    description?: Maybe<StringOperators>;\n};\n\nexport type ProductList = PaginatedList & {\n    __typename?: 'ProductList';\n    items: Array<Product>;\n    totalItems: Scalars['Int'];\n};\n\nexport type ProductListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<ProductSortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<ProductFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\nexport type ProductOption = Node & {\n    __typename?: 'ProductOption';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    code: Scalars['String'];\n    name: Scalars['String'];\n    groupId: Scalars['ID'];\n    group: ProductOptionGroup;\n    translations: Array<ProductOptionTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type ProductOptionGroup = Node & {\n    __typename?: 'ProductOptionGroup';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    code: Scalars['String'];\n    name: Scalars['String'];\n    options: Array<ProductOption>;\n    translations: Array<ProductOptionGroupTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type ProductOptionGroupTranslation = {\n    __typename?: 'ProductOptionGroupTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n};\n\nexport type ProductOptionTranslation = {\n    __typename?: 'ProductOptionTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n};\n\nexport type ProductSortParameter = {\n    id?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n    name?: Maybe<SortOrder>;\n    slug?: Maybe<SortOrder>;\n    description?: Maybe<SortOrder>;\n};\n\nexport type ProductTranslation = {\n    __typename?: 'ProductTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n    slug: Scalars['String'];\n    description: Scalars['String'];\n};\n\nexport type ProductVariant = Node & {\n    __typename?: 'ProductVariant';\n    id: Scalars['ID'];\n    product: Product;\n    productId: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    sku: Scalars['String'];\n    name: Scalars['String'];\n    featuredAsset?: Maybe<Asset>;\n    assets: Array<Asset>;\n    price: Scalars['Int'];\n    currencyCode: CurrencyCode;\n    priceWithTax: Scalars['Int'];\n    stockLevel: Scalars['String'];\n    taxRateApplied: TaxRate;\n    taxCategory: TaxCategory;\n    options: Array<ProductOption>;\n    facetValues: Array<FacetValue>;\n    translations: Array<ProductVariantTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type ProductVariantFilterParameter = {\n    id?: Maybe<IdOperators>;\n    productId?: Maybe<IdOperators>;\n    createdAt?: Maybe<DateOperators>;\n    updatedAt?: Maybe<DateOperators>;\n    languageCode?: Maybe<StringOperators>;\n    sku?: Maybe<StringOperators>;\n    name?: Maybe<StringOperators>;\n    price?: Maybe<NumberOperators>;\n    currencyCode?: Maybe<StringOperators>;\n    priceWithTax?: Maybe<NumberOperators>;\n    stockLevel?: Maybe<StringOperators>;\n};\n\nexport type ProductVariantList = PaginatedList & {\n    __typename?: 'ProductVariantList';\n    items: Array<ProductVariant>;\n    totalItems: Scalars['Int'];\n};\n\nexport type ProductVariantListOptions = {\n    /** Skips the first n results, for use in pagination */\n    skip?: Maybe<Scalars['Int']>;\n    /** Takes n results, for use in pagination */\n    take?: Maybe<Scalars['Int']>;\n    /** Specifies which properties to sort the results by */\n    sort?: Maybe<ProductVariantSortParameter>;\n    /** Allows the results to be filtered */\n    filter?: Maybe<ProductVariantFilterParameter>;\n    /** Specifies whether multiple \"filter\" arguments should be combines with a logical AND or OR operation. Defaults to AND. */\n    filterOperator?: Maybe<LogicalOperator>;\n};\n\nexport type ProductVariantSortParameter = {\n    id?: Maybe<SortOrder>;\n    productId?: Maybe<SortOrder>;\n    createdAt?: Maybe<SortOrder>;\n    updatedAt?: Maybe<SortOrder>;\n    sku?: Maybe<SortOrder>;\n    name?: Maybe<SortOrder>;\n    price?: Maybe<SortOrder>;\n    priceWithTax?: Maybe<SortOrder>;\n    stockLevel?: Maybe<SortOrder>;\n};\n\nexport type ProductVariantTranslation = {\n    __typename?: 'ProductVariantTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n};\n\nexport type Promotion = Node & {\n    __typename?: 'Promotion';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    startsAt?: Maybe<Scalars['DateTime']>;\n    endsAt?: Maybe<Scalars['DateTime']>;\n    couponCode?: Maybe<Scalars['String']>;\n    perCustomerUsageLimit?: Maybe<Scalars['Int']>;\n    name: Scalars['String'];\n    enabled: Scalars['Boolean'];\n    conditions: Array<ConfigurableOperation>;\n    actions: Array<ConfigurableOperation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type PromotionList = PaginatedList & {\n    __typename?: 'PromotionList';\n    items: Array<Promotion>;\n    totalItems: Scalars['Int'];\n};\n\nexport type Query = {\n    __typename?: 'Query';\n    /** The active Channel */\n    activeChannel: Channel;\n    /** The active Customer */\n    activeCustomer?: Maybe<Customer>;\n    /**\n     * The active Order. Will be `null` until an Order is created via `addItemToOrder`. Once an Order reaches the\n     * state of `PaymentAuthorized` or `PaymentSettled`, then that Order is no longer considered \"active\" and this\n     * query will once again return `null`.\n     */\n    activeOrder?: Maybe<Order>;\n    /** An array of supported Countries */\n    availableCountries: Array<Country>;\n    /** A list of Collections available to the shop */\n    collections: CollectionList;\n    /** Returns a Collection either by its id or slug. If neither 'id' nor 'slug' is specified, an error will result. */\n    collection?: Maybe<Collection>;\n    /** Returns a list of eligible shipping methods based on the current active Order */\n    eligibleShippingMethods: Array<ShippingMethodQuote>;\n    /** Returns a list of payment methods and their eligibility based on the current active Order */\n    eligiblePaymentMethods: Array<PaymentMethodQuote>;\n    /** A list of Facets available to the shop */\n    facets: FacetList;\n    /** Returns a Facet by its id */\n    facet?: Maybe<Facet>;\n    /** Returns information about the current authenticated User */\n    me?: Maybe<CurrentUser>;\n    /** Returns the possible next states that the activeOrder can transition to */\n    nextOrderStates: Array<Scalars['String']>;\n    /**\n     * Returns an Order based on the id. Note that in the Shop API, only orders belonging to the\n     * currently-authenticated User may be queried.\n     */\n    order?: Maybe<Order>;\n    /**\n     * Returns an Order based on the order `code`. For guest Orders (i.e. Orders placed by non-authenticated Customers)\n     * this query will only return the Order within 2 hours of the Order being placed. This allows an Order confirmation\n     * screen to be shown immediately after completion of a guest checkout, yet prevents security risks of allowing\n     * general anonymous access to Order data.\n     */\n    orderByCode?: Maybe<Order>;\n    /** Get a Product either by id or slug. If neither 'id' nor 'slug' is specified, an error will result. */\n    product?: Maybe<Product>;\n    /** Get a list of Products */\n    products: ProductList;\n    /** Search Products based on the criteria set by the `SearchInput` */\n    search: SearchResponse;\n};\n\nexport type QueryCollectionsArgs = {\n    options?: Maybe<CollectionListOptions>;\n};\n\nexport type QueryCollectionArgs = {\n    id?: Maybe<Scalars['ID']>;\n    slug?: Maybe<Scalars['String']>;\n};\n\nexport type QueryFacetsArgs = {\n    options?: Maybe<FacetListOptions>;\n};\n\nexport type QueryFacetArgs = {\n    id: Scalars['ID'];\n};\n\nexport type QueryOrderArgs = {\n    id: Scalars['ID'];\n};\n\nexport type QueryOrderByCodeArgs = {\n    code: Scalars['String'];\n};\n\nexport type QueryProductArgs = {\n    id?: Maybe<Scalars['ID']>;\n    slug?: Maybe<Scalars['String']>;\n};\n\nexport type QueryProductsArgs = {\n    options?: Maybe<ProductListOptions>;\n};\n\nexport type QuerySearchArgs = {\n    input: SearchInput;\n};\n\nexport type RefreshCustomerVerificationResult = Success | NativeAuthStrategyError;\n\nexport type Refund = Node & {\n    __typename?: 'Refund';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    items: Scalars['Int'];\n    shipping: Scalars['Int'];\n    adjustment: Scalars['Int'];\n    total: Scalars['Int'];\n    method?: Maybe<Scalars['String']>;\n    state: Scalars['String'];\n    transactionId?: Maybe<Scalars['String']>;\n    reason?: Maybe<Scalars['String']>;\n    orderItems: Array<OrderItem>;\n    paymentId: Scalars['ID'];\n    metadata?: Maybe<Scalars['JSON']>;\n};\n\nexport type RegisterCustomerAccountResult =\n    | Success\n    | MissingPasswordError\n    | PasswordValidationError\n    | NativeAuthStrategyError;\n\nexport type RegisterCustomerInput = {\n    emailAddress: Scalars['String'];\n    title?: Maybe<Scalars['String']>;\n    firstName?: Maybe<Scalars['String']>;\n    lastName?: Maybe<Scalars['String']>;\n    phoneNumber?: Maybe<Scalars['String']>;\n    password?: Maybe<Scalars['String']>;\n};\n\nexport type RelationCustomFieldConfig = CustomField & {\n    __typename?: 'RelationCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    entity: Scalars['String'];\n    scalarFields: Array<Scalars['String']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type RemoveOrderItemsResult = Order | OrderModificationError;\n\nexport type RequestPasswordResetResult = Success | NativeAuthStrategyError;\n\nexport type RequestUpdateCustomerEmailAddressResult =\n    | Success\n    | InvalidCredentialsError\n    | EmailAddressConflictError\n    | NativeAuthStrategyError;\n\nexport type ResetPasswordResult =\n    | CurrentUser\n    | PasswordResetTokenInvalidError\n    | PasswordResetTokenExpiredError\n    | PasswordValidationError\n    | NativeAuthStrategyError\n    | NotVerifiedError;\n\nexport type Role = Node & {\n    __typename?: 'Role';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    code: Scalars['String'];\n    description: Scalars['String'];\n    permissions: Array<Permission>;\n    channels: Array<Channel>;\n};\n\nexport type RoleList = PaginatedList & {\n    __typename?: 'RoleList';\n    items: Array<Role>;\n    totalItems: Scalars['Int'];\n};\n\nexport type SearchInput = {\n    term?: Maybe<Scalars['String']>;\n    facetValueIds?: Maybe<Array<Scalars['ID']>>;\n    facetValueOperator?: Maybe<LogicalOperator>;\n    facetValueFilters?: Maybe<Array<FacetValueFilterInput>>;\n    collectionId?: Maybe<Scalars['ID']>;\n    collectionSlug?: Maybe<Scalars['String']>;\n    groupByProduct?: Maybe<Scalars['Boolean']>;\n    take?: Maybe<Scalars['Int']>;\n    skip?: Maybe<Scalars['Int']>;\n    sort?: Maybe<SearchResultSortParameter>;\n};\n\nexport type SearchReindexResponse = {\n    __typename?: 'SearchReindexResponse';\n    success: Scalars['Boolean'];\n};\n\nexport type SearchResponse = {\n    __typename?: 'SearchResponse';\n    items: Array<SearchResult>;\n    totalItems: Scalars['Int'];\n    facetValues: Array<FacetValueResult>;\n    collections: Array<CollectionResult>;\n};\n\nexport type SearchResult = {\n    __typename?: 'SearchResult';\n    sku: Scalars['String'];\n    slug: Scalars['String'];\n    productId: Scalars['ID'];\n    productName: Scalars['String'];\n    productAsset?: Maybe<SearchResultAsset>;\n    productVariantId: Scalars['ID'];\n    productVariantName: Scalars['String'];\n    productVariantAsset?: Maybe<SearchResultAsset>;\n    price: SearchResultPrice;\n    priceWithTax: SearchResultPrice;\n    currencyCode: CurrencyCode;\n    description: Scalars['String'];\n    facetIds: Array<Scalars['ID']>;\n    facetValueIds: Array<Scalars['ID']>;\n    /** An array of ids of the Collections in which this result appears */\n    collectionIds: Array<Scalars['ID']>;\n    /** A relevance score for the result. Differs between database implementations */\n    score: Scalars['Float'];\n};\n\nexport type SearchResultAsset = {\n    __typename?: 'SearchResultAsset';\n    id: Scalars['ID'];\n    preview: Scalars['String'];\n    focalPoint?: Maybe<Coordinate>;\n};\n\n/** The price of a search result product, either as a range or as a single price */\nexport type SearchResultPrice = PriceRange | SinglePrice;\n\nexport type SearchResultSortParameter = {\n    name?: Maybe<SortOrder>;\n    price?: Maybe<SortOrder>;\n};\n\nexport type SetCustomerForOrderResult =\n    | Order\n    | AlreadyLoggedInError\n    | EmailAddressConflictError\n    | NoActiveOrderError;\n\nexport type SetOrderShippingMethodResult =\n    | Order\n    | OrderModificationError\n    | IneligibleShippingMethodError\n    | NoActiveOrderError;\n\nexport type ShippingLine = {\n    __typename?: 'ShippingLine';\n    shippingMethod: ShippingMethod;\n    price: Scalars['Int'];\n    priceWithTax: Scalars['Int'];\n    discountedPrice: Scalars['Int'];\n    discountedPriceWithTax: Scalars['Int'];\n    discounts: Array<Discount>;\n};\n\nexport type ShippingMethod = Node & {\n    __typename?: 'ShippingMethod';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    code: Scalars['String'];\n    name: Scalars['String'];\n    description: Scalars['String'];\n    fulfillmentHandlerCode: Scalars['String'];\n    checker: ConfigurableOperation;\n    calculator: ConfigurableOperation;\n    translations: Array<ShippingMethodTranslation>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type ShippingMethodList = PaginatedList & {\n    __typename?: 'ShippingMethodList';\n    items: Array<ShippingMethod>;\n    totalItems: Scalars['Int'];\n};\n\nexport type ShippingMethodQuote = {\n    __typename?: 'ShippingMethodQuote';\n    id: Scalars['ID'];\n    price: Scalars['Int'];\n    priceWithTax: Scalars['Int'];\n    code: Scalars['String'];\n    name: Scalars['String'];\n    description: Scalars['String'];\n    /** Any optional metadata returned by the ShippingCalculator in the ShippingCalculationResult */\n    metadata?: Maybe<Scalars['JSON']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type ShippingMethodTranslation = {\n    __typename?: 'ShippingMethodTranslation';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    languageCode: LanguageCode;\n    name: Scalars['String'];\n    description: Scalars['String'];\n};\n\n/** The price value where the result has a single price */\nexport type SinglePrice = {\n    __typename?: 'SinglePrice';\n    value: Scalars['Int'];\n};\n\nexport enum SortOrder {\n    ASC = 'ASC',\n    DESC = 'DESC',\n}\n\nexport type StringCustomFieldConfig = CustomField & {\n    __typename?: 'StringCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    length?: Maybe<Scalars['Int']>;\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    pattern?: Maybe<Scalars['String']>;\n    options?: Maybe<Array<StringFieldOption>>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type StringFieldOption = {\n    __typename?: 'StringFieldOption';\n    value: Scalars['String'];\n    label?: Maybe<Array<LocalizedString>>;\n};\n\n/** Operators for filtering on a list of String fields */\nexport type StringListOperators = {\n    inList: Scalars['String'];\n};\n\n/** Operators for filtering on a String field */\nexport type StringOperators = {\n    eq?: Maybe<Scalars['String']>;\n    notEq?: Maybe<Scalars['String']>;\n    contains?: Maybe<Scalars['String']>;\n    notContains?: Maybe<Scalars['String']>;\n    in?: Maybe<Array<Scalars['String']>>;\n    notIn?: Maybe<Array<Scalars['String']>>;\n    regex?: Maybe<Scalars['String']>;\n};\n\n/** Indicates that an operation succeeded, where we do not want to return any more specific information. */\nexport type Success = {\n    __typename?: 'Success';\n    success: Scalars['Boolean'];\n};\n\nexport type Surcharge = Node & {\n    __typename?: 'Surcharge';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    description: Scalars['String'];\n    sku?: Maybe<Scalars['String']>;\n    taxLines: Array<TaxLine>;\n    price: Scalars['Int'];\n    priceWithTax: Scalars['Int'];\n    taxRate: Scalars['Float'];\n};\n\nexport type Tag = Node & {\n    __typename?: 'Tag';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    value: Scalars['String'];\n};\n\nexport type TagList = PaginatedList & {\n    __typename?: 'TagList';\n    items: Array<Tag>;\n    totalItems: Scalars['Int'];\n};\n\nexport type TaxCategory = Node & {\n    __typename?: 'TaxCategory';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    name: Scalars['String'];\n    isDefault: Scalars['Boolean'];\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type TaxLine = {\n    __typename?: 'TaxLine';\n    description: Scalars['String'];\n    taxRate: Scalars['Float'];\n};\n\nexport type TaxRate = Node & {\n    __typename?: 'TaxRate';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    name: Scalars['String'];\n    enabled: Scalars['Boolean'];\n    value: Scalars['Float'];\n    category: TaxCategory;\n    zone: Zone;\n    customerGroup?: Maybe<CustomerGroup>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type TaxRateList = PaginatedList & {\n    __typename?: 'TaxRateList';\n    items: Array<TaxRate>;\n    totalItems: Scalars['Int'];\n};\n\nexport type TextCustomFieldConfig = CustomField & {\n    __typename?: 'TextCustomFieldConfig';\n    name: Scalars['String'];\n    type: Scalars['String'];\n    list: Scalars['Boolean'];\n    label?: Maybe<Array<LocalizedString>>;\n    description?: Maybe<Array<LocalizedString>>;\n    readonly?: Maybe<Scalars['Boolean']>;\n    internal?: Maybe<Scalars['Boolean']>;\n    nullable?: Maybe<Scalars['Boolean']>;\n    ui?: Maybe<Scalars['JSON']>;\n};\n\nexport type TransitionOrderToStateResult = Order | OrderStateTransitionError;\n\nexport type UpdateAddressInput = {\n    id: Scalars['ID'];\n    fullName?: Maybe<Scalars['String']>;\n    company?: Maybe<Scalars['String']>;\n    streetLine1?: Maybe<Scalars['String']>;\n    streetLine2?: Maybe<Scalars['String']>;\n    city?: Maybe<Scalars['String']>;\n    province?: Maybe<Scalars['String']>;\n    postalCode?: Maybe<Scalars['String']>;\n    countryCode?: Maybe<Scalars['String']>;\n    phoneNumber?: Maybe<Scalars['String']>;\n    defaultShippingAddress?: Maybe<Scalars['Boolean']>;\n    defaultBillingAddress?: Maybe<Scalars['Boolean']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type UpdateCustomerEmailAddressResult =\n    | Success\n    | IdentifierChangeTokenInvalidError\n    | IdentifierChangeTokenExpiredError\n    | NativeAuthStrategyError;\n\nexport type UpdateCustomerInput = {\n    title?: Maybe<Scalars['String']>;\n    firstName?: Maybe<Scalars['String']>;\n    lastName?: Maybe<Scalars['String']>;\n    phoneNumber?: Maybe<Scalars['String']>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type UpdateCustomerPasswordResult =\n    | Success\n    | InvalidCredentialsError\n    | PasswordValidationError\n    | NativeAuthStrategyError;\n\nexport type UpdateOrderInput = {\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\nexport type UpdateOrderItemsResult =\n    | Order\n    | OrderModificationError\n    | OrderLimitError\n    | NegativeQuantityError\n    | InsufficientStockError;\n\nexport type User = Node & {\n    __typename?: 'User';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    identifier: Scalars['String'];\n    verified: Scalars['Boolean'];\n    roles: Array<Role>;\n    lastLogin?: Maybe<Scalars['DateTime']>;\n    authenticationMethods: Array<AuthenticationMethod>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n\n/**\n * Returned if the verification token (used to verify a Customer's email address) is valid, but has\n * expired according to the `verificationTokenDuration` setting in the AuthOptions.\n */\nexport type VerificationTokenExpiredError = ErrorResult & {\n    __typename?: 'VerificationTokenExpiredError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\n/**\n * Returned if the verification token (used to verify a Customer's email address) is either\n * invalid or does not match any expected tokens.\n */\nexport type VerificationTokenInvalidError = ErrorResult & {\n    __typename?: 'VerificationTokenInvalidError';\n    errorCode: ErrorCode;\n    message: Scalars['String'];\n};\n\nexport type VerifyCustomerAccountResult =\n    | CurrentUser\n    | VerificationTokenInvalidError\n    | VerificationTokenExpiredError\n    | MissingPasswordError\n    | PasswordValidationError\n    | PasswordAlreadySetError\n    | NativeAuthStrategyError;\n\nexport type Zone = Node & {\n    __typename?: 'Zone';\n    id: Scalars['ID'];\n    createdAt: Scalars['DateTime'];\n    updatedAt: Scalars['DateTime'];\n    name: Scalars['String'];\n    members: Array<Country>;\n    customFields?: Maybe<Scalars['JSON']>;\n};\n"]}